# Trading Bot Complete Workflow Documentation

**Last Updated:** 2025-12-16  
**Version:** Comprehensive System Overview

---

## Table of Contents

1. [Signal Generation](#signal-generation)
2. [Signal Review Process](#signal-review-process)
3. [Trading Requirements & Conditions](#trading-requirements--conditions)
4. [Trade Execution](#trade-execution)
5. [Trade Monitoring & Exit Decisions](#trade-monitoring--exit-decisions)
6. [Post-Trade Review](#post-trade-review)
7. [Learning Engine](#learning-engine)
8. [Timing & Update Cycles](#timing--update-cycles)
9. [Kraken Integration](#kraken-integration)
10. [CoinGlass Integration](#coinglass-integration)

---

## Signal Generation

### Overview

The bot uses a **multi-factor predictive signal system** that combines multiple independent signals to generate trading opportunities. Signals are generated by the `PredictiveFlowEngine` which tracks momentum and flow-of-funds indicators rather than static snapshots.

### Signal Components (Ranked by Predictive Power)

The system uses **10 independent signal components** with the following weights:

1. **Liquidation Cascade Detection (22%)**
   - Detects forced selling/buying that creates momentum
   - Tracks liquidation volume and cascade patterns
   - Location: `src/predictive_flow_engine.py::LiquidationCascadeDetector`
   - Thresholds:
     - Paper mode: $50,000 minimum liquidation volume
     - Live mode: $100,000 minimum liquidation volume

2. **Whale Exchange Flows (20%)**
   - Tracks smart money positioning via exchange flows
   - Large inflows = bearish (selling pressure)
   - Large outflows = bullish (accumulation)
   - Location: `src/predictive_flow_engine.py::WhaleFlowSignal`
   - Thresholds:
     - Paper mode: $250,000 minimum flow
     - Live mode: $1,000,000 minimum flow

3. **Funding Rate Extremes (16%)**
   - Detects crowded trades that unwind violently
   - Extreme funding rates indicate sentiment extremes
   - Location: `src/predictive_flow_engine.py::FundingRateSignal`
   - Thresholds:
     - Paper mode: 0.0001 minimum deviation
     - Live mode: 0.0002 minimum deviation

4. **Hurst Exponent (8%)**
   - Measures trend persistence vs mean reversion
   - High Hurst = trending (momentum strategies work)
   - Low Hurst = mean reverting (contrarian strategies work)
   - Location: `src/predictive_flow_engine.py` (calculated in signal generation)

5. **Lead-Lag Signal (8%)**
   - Tracks correlation between BTC (leader) and altcoins
   - BTC moves often lead altcoin moves
   - Location: `src/lead_lag_signal.py`
   - Uses correlation analysis to predict direction

6. **Order Flow Momentum (6%)**
   - Rate of change of buy/sell pressure (not just magnitude)
   - Tracks OFI momentum over time windows
   - Location: `src/predictive_flow_engine.py::OFIMomentumTracker`
   - Maintains rolling window of OFI readings with timestamps

7. **Fear & Greed Contrarian (6%)**
   - Extreme sentiment reversals
   - <25 = Extreme Fear (contrarian buy)
   - >75 = Extreme Greed (contrarian sell)
   - Location: `src/predictive_flow_engine.py::FearGreedContrarian`
   - Thresholds:
     - Paper mode: <15 (fear), >85 (greed)
     - Live mode: <20 (fear), >80 (greed)

8. **Volatility Skew (5%)**
   - Loss aversion / complacency detection
   - Measures implied volatility differences
   - Location: `src/predictive_flow_engine.py` (calculated in signal generation)

9. **Open Interest Velocity (5%)**
   - New money flow direction
   - Tracks OI change percentage over time
   - Location: `src/predictive_flow_engine.py::OpenInterestVelocity`
   - Thresholds:
     - Paper mode: 0.5% minimum change
     - Live mode: 2.0% minimum change

10. **OI Divergence (4%)**
    - Price/OI trap detection
    - Detects when price and OI move in opposite directions
    - Location: `src/predictive_flow_engine.py` (calculated in signal generation)

### Signal Generation Process

1. **Data Collection** (`PredictiveFlowEngine.generate_signal()`)
   - Loads intelligence data from `feature_store/intelligence/`
   - Loads on-chain data from `feature_store/onchain/`
   - Loads funding rates from CoinGlass
   - Loads open interest data
   - Records current OFI reading with timestamp

2. **Individual Signal Computation**
   - Each signal component is computed independently
   - Returns direction (LONG/SHORT/NEUTRAL) and confidence (0-1)
   - Includes reasons/context for the signal

3. **Signal Alignment & Voting**
   - Counts LONG vs SHORT votes
   - Requires minimum 2 signals aligned for any direction
   - Calculates weighted confidence based on signal weights
   - Determines final direction based on majority vote

4. **Conviction Level Assignment**
   - **HIGH**: 4+ signals aligned, confidence ≥ 0.6, size multiplier 1.5x
   - **MEDIUM**: 3 signals aligned, confidence ≥ 0.4, size multiplier 1.0x
   - **LOW**: 2 signals aligned, confidence ≥ 0.3, size multiplier 0.5x
   - **NONE**: <2 signals aligned, size multiplier 0.0x (no trade)

5. **Output**
   - Signal logged to `logs/predictive_signals.jsonl`
   - Signal emitted to SignalBus for tracking
   - Returns signal dict with direction, conviction, confidence, reasons

### Paper vs Live Mode Differences

- **Paper Mode**: Relaxed thresholds to generate more signals for learning
- **Live Mode**: Stricter thresholds to reduce false signals
- Thresholds loaded from `configs/trading_config.json`

---

## Signal Review Process

### Overview

Signals go through multiple review gates before becoming trades. The review process uses **weighted scoring** rather than hard blocking - all signals can pass, but sizing is adjusted based on score.

### Review Pipeline

```
1. Predictive Signal Generation
   └─> PredictiveFlowEngine.generate_signal()
   
2. Ensemble Prediction
   └─> EnsemblePredictor.get_ensemble_prediction()
   └─> Logged to logs/ensemble_predictions.jsonl
   
3. Conviction Gate (Weighted Scoring)
   └─> ConvictionGate.evaluate()
   └─> NO BLOCKING - all signals pass, sizing adjusted
   └─> Signals logged via signal_tracker.log_signal()
   
4. Fee Gate
   └─> FeeAwareGate.evaluate_entry() / fee_arbiter()
   └─> Checks if expected edge > fees
   
5. Correlation Throttle
   └─> CorrelationThrottle.check_throttle()
   └─> Limits correlated positions
   
6. Intelligence Gate
   └─> IntelligenceGate.evaluate()
   └─> Checks market intelligence alignment
   └─> Adjusts sizing based on conflict/alignment
   
7. Hold Governor / Pre-Entry Gate
   └─> unified_pre_entry_gate()
   └─> Venue enforcement + profit gates + market intelligence
   └─> Logs ALL signals to signal universe for counterfactual learning
   
8. Final Signal → Trade Execution
   └─> run_entry_flow() → open_order_fn()
```

### Conviction Gate Details

**Location**: `src/conviction_gate.py::ConvictionGate.evaluate()`

**Key Features**:
- **NO BLOCKING**: All signals pass through, but sizing is adjusted
- Uses weighted scoring based on signal components
- Conviction levels: ULTRA, HIGH, MEDIUM, BASELINE, LOW, MINIMUM
- Size multipliers: 0.4x to 2.5x based on score

**Scoring Breakdown**:
- Weighted score from all signal components
- Historical performance adjustment (if available)
- Edge boost if expected edge > 0.5%
- Cascade boost if liquidation cascade active
- Regime bias multiplier based on market regime

**Output**:
- `should_trade`: Always `True` (no blocking)
- `direction`: LONG or SHORT
- `conviction`: ULTRA/HIGH/MEDIUM/BASELINE/LOW/MINIMUM
- `size_multiplier`: 0.4x to 2.5x
- `composite_score`: Weighted total score
- `expected_edge`: Expected profit after fees
- `signals`: Individual signal details
- `reasons`: List of reasons for the decision

### Fee Gate

**Location**: `src/fee_aware_gate.py`

**Purpose**: Ensures expected edge exceeds trading fees

**Checks**:
- Calculates expected profit after fees
- Compares to minimum edge threshold
- Can block trades if edge is insufficient

### Correlation Throttle

**Location**: `src/correlation_throttle.py`

**Purpose**: Limits exposure to correlated positions

**Checks**:
- Computes correlation matrix for all assets
- Limits positions in highly correlated assets
- Prevents over-concentration in similar trades

### Intelligence Gate

**Location**: `src/intelligence_gate.py`

**Purpose**: Evaluates market intelligence alignment

**Checks**:
- OFI alignment with direction
- Market intelligence signals (taker flow, liquidations, fear/greed)
- Conflict detection (signals pointing opposite directions)
- Sizing adjustments based on alignment:
  - Strong conflict: 0.4x multiplier
  - Moderate conflict: 0.6x multiplier
  - Weak conflict: 0.8x multiplier
  - Neutral: 0.85x multiplier
  - Aligned: 1.0x multiplier
  - Aligned boost: 1.3x multiplier

### Pre-Entry Gate (Unified Stack)

**Location**: `src/unified_stack.py::unified_pre_entry()`

**Purpose**: Final router-level and gate-level venue enforcement

**Checks**:
- Venue enforcement (futures-only)
- Profit gates
- Market intelligence context
- **IMPORTANT**: Logs ALL signals to signal universe for counterfactual learning (even blocked ones)

---

## Trading Requirements & Conditions

### Minimum Requirements for Trade Execution

1. **Signal Requirements**:
   - Minimum 2 signals aligned in same direction
   - Direction must be LONG or SHORT (not NEUTRAL)
   - Conviction level must be MEDIUM or higher (for standard sizing)

2. **Portfolio Requirements**:
   - Available margin must exceed position size
   - Portfolio value must meet minimum threshold
   - Risk check must pass (margin available)

3. **Position Requirements**:
   - No existing position in same symbol/direction
   - Position count limits not exceeded
   - Correlation limits not exceeded

4. **Market Requirements**:
   - Market data available and fresh
   - Exchange connectivity verified
   - Price data valid

5. **Policy Requirements**:
   - Alpha trading enabled (if using alpha signals)
   - Symbol enabled in signal policies
   - No kill-switch active
   - No freeze on entries

### Signal Policy Check

**Location**: `src/bot_cycle.py` (lines 1272-1286)

**Configuration**: `configs/signal_policies.json`

**Checks**:
- `alpha_trading.enabled` must be `true`
- Symbol must be in `enabled_symbols` list
- If policy check fails, signal is blocked before conviction gate

### Risk Check

**Location**: `src/bot_cycle.py` (pre-cycle risk check)

**Checks**:
- Available margin vs required margin
- Portfolio value vs minimum threshold
- Margin recomputation and validation
- If risk check fails, trading cycle is skipped

### Position Limits

- Maximum positions per symbol
- Maximum total positions
- Maximum portfolio exposure
- Correlation-based limits

---

## Trade Execution

### Execution Flow

1. **Signal Processing**
   - Signal passes all gates
   - Final sizing calculated (base size × multipliers)
   - Direction confirmed (LONG or SHORT)

2. **Position Sizing**
   - Base notional calculated from portfolio allocation
   - Multipliers applied:
     - Conviction multiplier
     - Historical performance multiplier
     - Regime bias multiplier
     - Intelligence alignment multiplier
   - Final size normalized to exchange requirements

3. **Order Placement**
   - **Kraken**: Uses `KrakenFuturesClient.place_order()`
   - **Blofin**: Uses `BlofinFuturesClient.place_order()`
   - Order type: Market or Limit (based on configuration)
   - Leverage: Set per position (typically 2-5x)

4. **Position Tracking**
   - Position recorded in `state/positions_futures.json`
   - Portfolio updated with margin allocation
   - Signal tracked in SignalBus
   - Grace window registered (prevents immediate closure)

5. **Confirmation**
   - Order ID recorded
   - Entry price confirmed
   - Position metadata stored:
     - Symbol, direction, size, leverage
     - Strategy, signal context
     - Entry timestamp, MTF alignment
     - Timing intelligence ID

### Exchange-Specific Execution

#### Kraken Futures

**Client**: `src/kraken_futures_client.py::KrakenFuturesClient`

**Features**:
- HMAC-SHA512 authentication
- Rate limiting via `KrakenRateLimiter`
- Symbol normalization (BTCUSDT → PI_XBTUSD)
- Contract specifications enforcement
- Testnet support

**Order Placement**:
- Endpoint: `/derivatives/api/v3/sendorder`
- Symbol normalization required
- Contract size normalization
- Tick size rounding

#### Blofin Futures

**Client**: `src/blofin_futures_client.py::BlofinFuturesClient`

**Features**:
- API key authentication
- Standard futures trading
- Position management

### Grace Window Protection

**Purpose**: Prevents immediate closure of newly opened positions

**Implementation**:
- 2-minute grace window for standard trades
- 5-minute grace window for high-conviction trades
- Grace window tracked per position
- Exit logic respects grace window

---

## Trade Monitoring & Exit Decisions

### Overview

The bot continuously monitors open positions and makes exit decisions based on multiple factors:

1. **Position Timing Intelligence**
2. **Multi-Timeframe (MTF) Alignment**
3. **Profit Targets**
4. **Stop Losses**
5. **Time-Based Exits**
6. **Signal Reversal**

### Exit Decision Components

#### 1. Position Timing Intelligence

**Location**: `src/position_timing_intelligence.py::check_exit_timing()`

**Purpose**: Intelligence-driven hold/extend/exit decisions

**Key Factors**:
- **MTF Alignment**: Current multi-timeframe alignment score
- **Momentum Continuation**: Whether momentum is continuing in favor of position
- **Alignment Change**: How alignment has changed since entry
- **Optimal Hold Time**: Learned optimal hold duration for symbol/direction

**Exit Actions**:
- **HOLD**: Standard hold, alignment OK
- **HOLD_EXTENDED**: Strong alignment + momentum continuing (hold 50% longer)
- **EXIT_NOW**: Alignment degraded OR momentum reversed
- **EXIT_SOONER**: Alignment degraded but not critical
- **TAKE_PROFIT**: Good profit + alignment weakening (lock in gains)
- **FORCE_EXIT**: Stop loss triggered OR significantly exceeded optimal time

**Minimum Hold Time**: 5 minutes (300 seconds) before any early exit triggers

**Logic**:
```python
# Strong alignment + momentum = HOLD LONGER
if current_alignment >= 0.75 and momentum_continuing:
    action = 'HOLD_EXTENDED'
    hold_multiplier = 1.5  # Allow 50% longer than optimal

# Alignment degraded = EXIT SOONER (after min hold)
if alignment_degraded and hold_duration > 300:
    action = 'EXIT_SOONER'

# Profit + alignment weakening = TAKE PROFIT
if pnl_pct > 1.5 and (alignment_degraded or not momentum_continuing) and hold_duration > 300:
    action = 'TAKE_PROFIT'

# Stop loss = FORCE EXIT
if pnl_pct < -2.5:
    action = 'FORCE_EXIT'
```

#### 2. Multi-Timeframe (MTF) Alignment

**Location**: `src/multi_timeframe.py`

**Purpose**: Confirms signal across multiple timeframes

**Timeframes Checked**:
- 1m, 5m, 15m, 1h, 4h, 1d

**Alignment Calculation**:
- Counts timeframes aligned with position direction
- Calculates alignment score (0-1)
- Tracks alignment change since entry

**Exit Triggers**:
- Alignment degraded significantly (< 0.15)
- Alignment delta < -0.25 (degraded)
- Momentum reversed against position

#### 3. Profit Targets

**Location**: `src/phase92_profit_discipline.py::phase92_get_exit_recommendations()`

**Tiered Profit Targets**:
- **Tier 1**: +0.5% after 30 minutes
- **Tier 2**: +1.0% after 60 minutes
- **Tier 3**: +1.5% after 90 minutes
- **Tier 4**: +2.0% anytime (big winners)

**Take Profit Logic**:
- Profitable + alignment weakening = TAKE PROFIT (don't give it back)
- Very profitable + extended hold = TAKE PROFIT
- Profit + strong alignment = LET IT RUN

#### 4. Stop Losses

**Stop Loss Threshold**: -2.5% (widened from -1.5% to give positions room to develop)

**Implementation**:
- Checked every cycle
- Triggers FORCE_EXIT immediately
- No grace window for stop loss

#### 5. Time-Based Exits

**Tiered Time Exits** (from `phase92_profit_discipline.py`):
- **Tier 1**: Exit after 2h if losing > 0.5%
- **Tier 2**: Exit after 4h if gain < 0.2%
- **Tier 3**: Exit after 8h if gain < 0.5%

**Optimal Hold Time**:
- Learned from historical performance
- Symbol/direction specific
- Adjusted based on MTF alignment
- Extended if alignment strong + momentum continuing

#### 6. Signal Reversal

**Location**: `src/futures_ladder_exits.py::evaluate_exit_triggers()`

**Purpose**: Detects when signal has reversed (EMA crossover flip)

**Trigger**:
- Original signal direction reversed
- Can accelerate exits if reversal detected

### Exit Execution

1. **Exit Decision Made**
   - `check_exit_timing()` returns exit recommendation
   - Exit reason recorded
   - Confidence score calculated

2. **Position Closure**
   - `close_futures_position()` called
   - Order placed on exchange
   - Position removed from open positions

3. **Trade Recording**
   - Trade recorded in `state/trades_futures.json`
   - P&L calculated (net of fees)
   - Duration tracked
   - Exit reason stored

4. **Post-Trade Updates**
   - Portfolio updated
   - Learning systems notified
   - Attribution updated
   - Timing intelligence outcome recorded

### Ladder Exits

**Location**: `src/futures_ladder_exits.py`

**Purpose**: Gradual position scaling via ladder exits

**Implementation**:
- Multiple exit tiers (e.g., 25%, 50%, 25%)
- Each tier has profit target and time constraint
- Timing intelligence can suppress or accelerate exits
- HOLD_EXTENDED: Suppresses most exits
- EXIT_NOW/TAKE_PROFIT: Accelerates exits

---

## Post-Trade Review

### Overview

After a trade closes, multiple systems analyze the outcome and update learning models.

### Post-Trade Processing Pipeline

1. **Trade Closure Recording**
   - Trade recorded in `state/trades_futures.json`
   - Portfolio updated with realized P&L
   - Position removed from active positions

2. **Unified Trade Close Handler**
   - **Location**: `src/unified_stack.py::unified_on_trade_close()`
   - Coordinates all post-trade updates

3. **Attribution Updates**
   - **Location**: `src/phase101_attribution.py`
   - Attributes P&L to symbol, strategy, venue
   - Updates performance metrics

4. **Expectancy Ledger**
   - **Location**: `src/phase1013_1015.py::phase1013_on_trade_close()`
   - Updates expectancy ledger with:
     - Net P&L (after fees)
     - Execution quality (exec_edge_bps)
     - Exit efficiency (0.0-1.0)
   - Decay-weighted moving averages

5. **Calibration Snapshots**
   - **Location**: `src/phase106_108.py::phase106_on_trade_close()`
   - Records prediction calibration
   - Updates calibration accuracy

6. **Prediction Calibration**
   - **Location**: `src/phase107_109.py::phase107_on_trade_close()`
   - Compares predicted vs actual outcomes
   - Updates prediction accuracy

7. **Meta-Bucket Aggregation**
   - **Location**: `src/phase1016_1018.py::phase1016_on_trade_close()`
   - Aggregates outcomes by meta-buckets
   - Updates meta-level statistics

8. **Timing Intelligence Outcome**
   - **Location**: `src/position_timing_intelligence.py::close_position_tracking()`
   - Records actual hold duration vs optimal
   - Records exit reason and P&L
   - Updates timing learning models

9. **Counter-Signal Orchestrator**
   - **Location**: `src/counter_signal_orchestrator.py::record_signal_outcome()`
   - Records outcome for pattern learning
   - Tracks if signal was inverted

10. **Data Sync**
    - **Location**: `src/data_sync_module.py::sync_single_trade()`
    - Syncs trade to `executed_trades.jsonl` for learning systems
    - Ensures data integrity

### Post-Trade Analysis

#### Comprehensive Trade Analysis

**Location**: `src/comprehensive_trade_analysis.py`

**Purpose**: Deep dive postmortem analysis

**Analyzes**:
1. Execution bugs vs signal logic issues
2. Why trades are losing money
3. How to improve performance
4. OFI-direction alignment
5. Ladder reversal patterns
6. Symbol-specific performance

#### Extended Trade Analysis

**Location**: `src/extended_trade_analysis.py`

**Purpose**: Extended analysis of trade outcomes

**Analyzes**:
- Trade duration vs profitability
- Exit timing effectiveness
- Signal quality assessment
- Fee impact analysis

#### Strategic Advisor

**Location**: `src/strategic_advisor.py`

**Purpose**: Hourly profitability gap analysis

**Analyzes**:
- Recent trades (last 24 hours)
- Fee impact
- Exit timing
- Correlation losses
- Generates recommendations

### Learning Integration

All post-trade data flows into learning systems:
- **Signal Weight Learner**: Updates signal weights based on outcomes
- **Profit Target & Sizing Intelligence**: Adjusts profit targets and sizing
- **Timing Intelligence**: Learns optimal hold times
- **Counterfactual Learning**: Analyzes what-if scenarios

---

## Learning Engine

### Overview

The bot uses a comprehensive learning system that continuously improves performance by analyzing outcomes and adjusting parameters.

### Learning Components

#### 1. Continuous Learning Controller

**Location**: `src/continuous_learning_controller.py::ContinuousLearningController`

**Purpose**: Main coordinator for all learning components

**Cycle Frequency**: Every 30 minutes (configurable)

**Process**:
1. **Signal Resolution**
   - Resolves pending signals at forward horizons (1m, 5m, 15m, 30m, 1h)
   - Updates signal outcomes in `signal_outcomes.jsonl`

2. **Data Capture**
   - Loads executed trades (last 168 hours by default)
   - Loads blocked signals
   - Loads missed opportunities

3. **Profitability Analysis**
   - Analyzes executed trades
   - Calculates win rates, P&L, expectancy
   - Identifies profitable vs unprofitable patterns

4. **Adjustment Generation**
   - Generates gate feedback (tighten/loosen gates)
   - Generates weight adjustments (signal weights)
   - Generates sizing adjustments (position sizing)

5. **Signal Weight Updates**
   - Updates signal weights based on performance
   - Uses `src/signal_weight_learner.py`
   - Adjusts weights for each signal component

6. **Direction Learning**
   - Evaluates direction routing effectiveness
   - Uses `src/enhanced_signal_learner.py`
   - Recommends direction adjustments

**Output**:
- Learning state with all analysis results
- Pending adjustments for application
- Cadence tracking (fast/daily/weekly cycles)

#### 2. Signal Weight Learner

**Location**: `src/signal_weight_learner.py::SignalWeightLearner`

**Purpose**: Updates signal component weights based on historical performance

**Process**:
1. Loads signal outcomes from `signal_outcomes.jsonl`
2. Calculates performance by signal component
3. Adjusts weights based on win rate and P&L
4. Updates weights in `feature_store/signal_weights.json`

**Weight Updates**:
- Increases weights for signals with high win rates
- Decreases weights for signals with low win rates
- Maintains minimum weights to prevent over-optimization

#### 3. Profit Target & Sizing Intelligence

**Location**: `src/profit_target_sizing_intelligence.py`

**Purpose**: Learns optimal profit targets and position sizing

**Process**:
1. Analyzes historical trades
2. Identifies optimal profit targets by symbol/strategy
3. Learns optimal position sizing multipliers
4. Updates profit targets and sizing rules

**Output**:
- Optimal profit targets per symbol/strategy
- Sizing multipliers based on confidence
- Hold time recommendations

#### 4. Timing Intelligence

**Location**: `src/position_timing_intelligence.py`

**Purpose**: Learns optimal hold times for positions

**Process**:
1. Tracks position entry/exit times
2. Analyzes P&L vs hold duration
3. Learns optimal hold times by symbol/direction
4. Updates timing rules

**Output**:
- Optimal hold duration buckets (short/medium/long)
- Timing recommendations for new positions
- Exit timing intelligence

#### 5. Enhanced Learning Engine

**Location**: `src/learning/enhanced_learning_engine.py::EnhancedLearningEngine`

**Purpose**: Comprehensive learning that reviews all aspects

**Reviews**:
1. **Blocked Trades Analysis**: What did we miss?
2. **Missed Opportunities**: What would have happened?
3. **What-If Scenarios**: Different weights/parameters
4. **Guard Effectiveness**: Which guards help/hurt?
5. **Strategy Performance**: Which strategies work best?
6. **Feedback Loop**: Directly improve signal generation

**Cycle Frequency**: Daily (nightly)

#### 6. Counterfactual Learning

**Location**: `src/counterfactual_scaling_engine.py`

**Purpose**: Analyzes what-if scenarios for blocked signals

**Process**:
1. Loads blocked signals
2. Simulates what would have happened if traded
3. Compares simulated vs actual outcomes
4. Identifies missed opportunities
5. Adjusts gates/parameters based on findings

#### 7. Meta-Learning Orchestrator

**Location**: `src/meta_learning_orchestrator.py::MetaLearningOrchestrator`

**Purpose**: High-level learning that coordinates multiple learning systems

**Process**:
1. Coordinates multiple learning cycles
2. Resolves conflicts between learning systems
3. Applies adjustments with validation
4. Monitors learning effectiveness

### Learning Cadence

- **Fast Cycle**: Every 30 minutes
  - Signal resolution
  - Quick adjustments
  - Performance monitoring

- **Daily Cycle**: Once per day (nightly)
  - Comprehensive analysis
  - Weight updates
  - Strategy evaluation

- **Weekly Cycle**: Once per week
  - Deep analysis
  - Major adjustments
  - Strategy optimization

### Learning Outputs

All learning results are stored in:
- `feature_store/` - Learned parameters and weights
- `logs/learning_audit.jsonl` - Learning cycle logs
- `feature_store/enhanced_learnings.json` - Comprehensive learnings

---

## Timing & Update Cycles

### Main Bot Cycle

**Location**: `src/bot_cycle.py::run_bot_cycle()`

**Frequency**: Every 60 seconds (configurable)

**Process**:
1. **Portfolio Reconciliation** (hourly)
   - Verifies portfolio metadata
   - Detects discrepancies
   - Runs reconciliation if needed

2. **Unified Venue Enforcement**
   - Initializes futures-only enforcement
   - Runs periodic checks

3. **Heartbeat Monitoring**
   - Emits heartbeats for all subsystems
   - Prevents kill-switch from stale subsystems

4. **Kill-Switch Check**
   - Evaluates performance metrics
   - Checks drawdown, win rate, reject rate
   - Activates kill-switch if thresholds exceeded

5. **Metrics Refresh**
   - Refreshes performance metrics
   - Ensures fresh data before trading

6. **Risk Check**
   - Pre-cycle risk validation
   - Margin recomputation
   - Portfolio value verification

7. **Regime Prediction**
   - Predicts current market regime
   - Selects active strategies for regime

8. **Capital Allocation**
   - Allocates capital per symbol
   - Adaptive allocation based on performance

9. **Signal Generation** (per symbol)
   - Generates alpha signals
   - Processes through conviction gate
   - Executes trades if conditions met

10. **Position Monitoring**
    - Updates peak/trough prices
    - Checks exit conditions
    - Executes exits if triggered

11. **Learning Cycle** (every 30 minutes)
    - Runs continuous learning controller
    - Updates signal weights
    - Applies adjustments

### Scheduler

**Location**: `src/scheduler_with_analysis.py::start_unified_scheduler()`

**Frequency**: Every 10 minutes (default)

**Tasks**:
- Fee audit
- Recovery cycle
- Override audit

**Nightly Tasks** (07:00 UTC):
- Data enrichment
- Scenario replay auto-tuner
- Upgrade pack v7.2+
- Expire manual overrides
- Digest generation
- Desk-grade analysis
- Counterfactual learning
- Multi-horizon attribution
- Missed opportunity probe
- Horizon-weighted evolution
- Gate complexity monitor
- Meta-governance watchdogs
- Multi-agent coordinator
- Strategy auto-tuning
- Unified nightly digest
- Profit-driven evolution
- Profit-first governor

### Self-Governance

**Location**: `src/self_governance.py::start_self_governance()`

**Tasks**:
- **Watchdog**: Every 5 minutes
  - Monitors system health
  - Detects anomalies
  - Triggers recovery

- **Tactical Operator**: Every 15 minutes
  - Quick adjustments
  - Performance monitoring
  - Gate tuning

- **Strategic Review**: Daily
  - Comprehensive analysis
  - Strategy evaluation
  - Major adjustments

- **Maintenance**: Daily
  - Data cleanup
  - Log rotation
  - System optimization

### Update Frequencies Summary

| Component | Frequency | Location |
|-----------|-----------|----------|
| Main Bot Cycle | 60 seconds | `bot_cycle.py` |
| Learning Cycle | 30 minutes | `continuous_learning_controller.py` |
| Scheduler | 10 minutes | `scheduler_with_analysis.py` |
| Watchdog | 5 minutes | `self_governance.py` |
| Tactical Operator | 15 minutes | `self_governance.py` |
| Strategic Review | Daily | `self_governance.py` |
| Nightly Tasks | Daily (07:00 UTC) | `scheduler_with_analysis.py` |

---

## Kraken Integration

### Overview

The bot supports Kraken Futures for trading execution. Integration is handled through the `KrakenFuturesClient` which provides a unified interface matching the Blofin client.

### Client Implementation

**Location**: `src/kraken_futures_client.py::KrakenFuturesClient`

### Authentication

**Method**: HMAC-SHA512

**Process**:
1. Generate nonce (timestamp in milliseconds)
2. Concatenate: `post_data + nonce + endpoint_path`
3. SHA-256 hash of concatenated string
4. HMAC-SHA-512 of SHA-256 hash (using base64-decoded API secret)
5. Base64 encode to get `Authent` value

**Headers**:
- `APIKey`: API key
- `Authent`: HMAC signature
- `Nonce`: Timestamp nonce
- `Content-Type`: application/x-www-form-urlencoded or application/json

### Rate Limiting

**Location**: `src/kraken_rate_limiter.py::KrakenRateLimiter`

**Limits** (conservative estimates):
- 10 requests per second
- 1000 requests per minute
- Thread-safe implementation
- Automatic backoff on rate limit errors

### Symbol Normalization

**Location**: `src/exchange_utils.py`

**Mapping**:
- Internal format: `BTCUSDT`
- Kraken format: `PI_XBTUSD`

**Supported Symbols**:
- BTCUSDT → PI_XBTUSD
- ETHUSDT → PF_ETHUSD
- SOLUSDT → PF_SOLUSD
- (Additional symbols in `KRAKEN_SYMBOL_MAP`)

### Contract Specifications

**Location**: `src/kraken_contract_specs.py`

**Features**:
- Contract size per symbol
- Tick size (minimum price increment)
- Minimum order size
- Leverage limits

**Usage**:
- Normalizes order sizes to contract requirements
- Rounds prices to tick size
- Validates minimum order sizes

### API Endpoints Used

1. **Ticker** (`/derivatives/api/v3/tickers`)
   - Get current mark price
   - Get 24h statistics

2. **OHLCV** (`/api/charts/v1/:tick_type/:symbol/:resolution`)
   - Fetch historical candle data
   - Supports: 1m, 5m, 15m, 1h, 4h, 1d

3. **Orderbook** (`/derivatives/api/v3/orderbook`)
   - Get current orderbook
   - Calculate order flow imbalance (OFI)

4. **Send Order** (`/derivatives/api/v3/sendorder`)
   - Place market/limit orders
   - Set leverage
   - Set take profit / stop loss

5. **Positions** (`/derivatives/api/v3/positions`)
   - Get open positions
   - Monitor position status

6. **Balance** (`/derivatives/api/v3/accounts`)
   - Get account balance (not supported on testnet)

### Testnet Support

**Configuration**: `KRAKEN_FUTURES_TESTNET` environment variable

**Testnet URL**: `https://demo-futures.kraken.com`

**Features**:
- Same API interface as production
- Paper trading mode
- Balance endpoint limitation (expected)

### Exchange Gateway Integration

**Location**: `src/exchange_gateway.py::ExchangeGateway`

**Purpose**: Unified interface for multiple exchanges

**Routing**:
- Determines exchange from `EXCHANGE` env var or parameter
- Routes to appropriate client (Kraken or Blofin)
- Maintains compatibility with existing code

### Usage in Bot

The bot uses Kraken through the exchange gateway:

```python
from src.exchange_gateway import ExchangeGateway

gateway = ExchangeGateway(exchange="kraken")
price = gateway.get_price(symbol, venue="futures")
order_id = gateway.place_order(symbol, side, order_type, size, leverage)
```

### Environment Variables

Required for Kraken integration:
- `KRAKEN_FUTURES_API_KEY`: API key
- `KRAKEN_FUTURES_API_SECRET`: API secret (base64-encoded)
- `KRAKEN_FUTURES_TESTNET`: "true" or "false" (optional)
- `EXCHANGE`: "kraken" or "blofin" (determines which exchange to use)

---

## CoinGlass Integration

### Overview

CoinGlass provides market microstructure intelligence including funding rates, open interest, liquidations, and long/short ratios. The bot uses CoinGlass data to enrich trading signals.

### API Configuration

**Base URL**: `https://open-api-v4.coinglass.com`

**Rate Limits**:
- Hobbyist plan: 30 requests per minute
- Minimum delay: 2.5 seconds between calls
- Rate limiter enforces delays automatically

**Authentication**:
- API key in `COINGLASS_API_KEY` environment variable
- Header: `CG-API-KEY: <api_key>`

### Data Endpoints Used

1. **Taker Buy/Sell Volume** (`/api/futures/taker-buy-sell-volume/exchange-list`)
   - Order flow direction
   - Buy/sell ratio
   - Volume in USD

2. **Liquidations** (`/api/futures/liquidation/coin-list`)
   - 24h liquidation data
   - Long vs short liquidations
   - 1h and 4h liquidation data

3. **Fear & Greed Index** (`/api/index/fear-greed-history`)
   - Macro sentiment indicator
   - 0-100 scale
   - Historical data

4. **Exchange Balance** (`/api/exchange/balance/list`)
   - Exchange inflows/outflows
   - Balance change percentage
   - Whale flow detection

### Integration Points

#### 1. Market Intelligence Module

**Location**: `src/market_intelligence.py`

**Purpose**: Primary CoinGlass integration for signal generation

**Functions**:
- `get_taker_buy_sell()`: Gets order flow data
- `get_liquidations()`: Gets liquidation data
- `get_fear_greed()`: Gets Fear & Greed Index
- `compute_signals()`: Computes trading signals from CoinGlass data

**Signal Logic**:
- **Taker Flow (40%)**: Buy/sell ratio > 1.15 = bullish, < 0.87 = bearish
- **Liquidation (40%)**: Long liq ratio > 0.60 = bearish, < 0.40 = bullish
- **Fear & Greed (20%)**: < 25 = contrarian buy, > 75 = contrarian sell

**Caching**:
- Data cached to `feature_store/intelligence/`
- Reduces API calls
- Updates periodically

#### 2. CoinGlass Intelligence Module

**Location**: `src/coinglass_intelligence.py::CoinGlassClient`

**Purpose**: Comprehensive CoinGlass data fetching and feature derivation

**Features**:
- Backfill historical data
- Polling for real-time updates
- Feature derivation (OI delta, funding z-score, liquidation sums)
- Caching to `feature_store/coinglass/`

**Endpoints Supported**:
- Funding rates (`/funding_ohlc_history`)
- Open interest (`/open_interest_ohlc_history`)
- Liquidations (`/liquidation_history`)
- Long/short ratios (`/top_long_short_position_ratio_history`)

#### 3. On-Chain Fetcher

**Location**: `src/onchain_fetcher.py`

**Purpose**: Fetches on-chain data including CoinGlass exchange flows

**Features**:
- Exchange balance changes
- Whale transaction detection
- Exchange flow analysis

**CoinGlass Integration**:
- Uses `/api/exchange/balance/list` endpoint
- Tracks exchange inflows/outflows
- Identifies whale movements

### Data Flow

1. **Data Fetching**
   - CoinGlass data fetched periodically
   - Cached to `feature_store/coinglass/` and `feature_store/intelligence/`

2. **Signal Generation**
   - PredictiveFlowEngine loads CoinGlass data
   - Computes signals using CoinGlass indicators
   - Enriches signals with CoinGlass context

3. **Real-Time Updates**
   - Market intelligence module polls CoinGlass
   - Updates cached data
   - Feeds into signal generation

### Configuration

**Location**: `configs/coinglass_config.json`

**Settings**:
- API configuration (base URL, rate limits)
- Backfill settings (enabled, days)
- Polling settings (interval, endpoints)
- Symbol list
- Feature flags

### Rate Limit Management

**Implementation**: `src/market_intelligence.py::_rate_limit()`

**Strategy**:
- Tracks last API call timestamp
- Enforces 2.5 second minimum delay
- Handles 429 rate limit errors with 60s backoff
- Thread-safe implementation

### Data Usage in Signals

CoinGlass data is used in multiple signal components:

1. **Funding Rate Signal**: Uses funding rates from CoinGlass
2. **Liquidation Signal**: Uses liquidation data from CoinGlass
3. **Whale Flow Signal**: Uses exchange balance data from CoinGlass
4. **Fear & Greed Signal**: Uses Fear & Greed Index from CoinGlass
5. **Open Interest Signal**: Uses OI data from CoinGlass

### Caching Strategy

- **Intelligence Data**: Cached to `feature_store/intelligence/`
  - `taker_buy_sell.json`
  - `liquidations.json`
  - `fear_greed.json`

- **CoinGlass Features**: Cached to `feature_store/coinglass/`
  - Historical data
  - Derived features
  - Exchange-specific data

- **Update Frequency**: 
  - Real-time: Every bot cycle (60 seconds)
  - Historical: Daily backfill
  - Features: Derived on-demand

### Error Handling

- Graceful degradation if API unavailable
- Fallback to cached data
- Neutral signals if data missing
- Logging of API errors

---

## Summary

This trading bot is a comprehensive, multi-layered system that:

1. **Generates Signals** using 10 independent components tracking flow-of-funds, momentum, and sentiment
2. **Reviews Signals** through multiple gates that adjust sizing rather than blocking
3. **Executes Trades** on Kraken or Blofin with proper position sizing and risk management
4. **Monitors Positions** using timing intelligence, MTF alignment, and profit targets
5. **Makes Exit Decisions** based on multiple factors including alignment, momentum, profit, and time
6. **Learns Continuously** from outcomes, updating weights, targets, and strategies
7. **Integrates with Kraken** for futures trading with proper authentication and rate limiting
8. **Integrates with CoinGlass** for market microstructure intelligence

The system is designed for continuous improvement, with learning cycles running every 30 minutes and comprehensive analysis running nightly. All components work together to create a self-improving trading system that adapts to market conditions.

---

**Document Version**: 1.0  
**Last Updated**: 2025-12-16  
**Maintained By**: Trading Bot Development Team
